# SnowFlake

添加了新的构造函数用于自定义 **开始时间戳、数据中心标识位数、机器标识位数、序列号位数** （具体位数定义参见下方原作者 README），这里提示一下 **时间戳部分** 存储的值是 **当前时间戳 - 自定义的开始时间戳** 。

如果想使用 SnowFlake 原生的默认位数，可以在构造函数中只传入两个值即 machineId 和 dataCenterId。

还添加了一个开始时间戳的 setter 方法，用于刷新 ID（即用于修改 startStamp 变量），注意修改了 startStamp 之后就会 **生成重复的 ID** ，只有当该算法生成的 ID 只是序列号的一部分时（如序列号由 (日期 + ID) 组成时），才应该考虑使用 setter 方法重置开始时间戳。

可能会有生成 **固定十进制位数 ID** 的需求，如果指定 SnowFlake 生成的十进制位数并限定序列号位数、数据中心位数、机器位数，那么就会 **压缩** 时间戳的位数，这有可能导致生成的 ID 会在短时间内产生重复。所以这种功能没有必要提供接口，需要通过程序员自己权衡把控。

**PS：这个项目 fork 自他人，原作者的原 README 在分割线下方。**

---
Twitter的雪花算法SnowFlake，使用Java语言实现。

SnowFlake算法用来生成64位的ID，刚好可以用long整型存储，能够用于分布式系统中生产唯一的ID， 并且生成的ID有大致的顺序。
在这次实现中，生成的64位ID可以分成5个部分：

  `0 - 41位时间戳 - 5位数据中心标识 - 5位机器标识 - 12位序列号`
  
5位数据中心标识跟5位机器标识这样的分配仅仅是当前实现中分配的，如果业务有其实的需要，可以按其它的分配比例分配，如10位机器标识，不需要数据中心标识。

具体说明可以参考文章：
[http://www.wolfbe.com/detail/201611/381.html](http://www.wolfbe.com/detail/201611/381.html)


生成的ID如下所示：

2099698216983

2099698216984

2099698216985

2099698216986

2099698216987

2099698216988

2099698216989

2099698216990

2099698216991

2099698216992

2099698216993

2099698216994

2099698216995

2099698216996

2099698216997

2099698216998

2099698216999

2099698217000

2099698217001

2099698217002

2099698217003

2099698217004

2099698217005

2099698217006

2099698217007

2099698217008

2099698217009

2099698217010

2099698217011

2099698217012

2099698217013

2099698217014

2099698217015

2099698217016

2099698217017

2099698217018

2099698217019
<br>
<br>
## 赞助
如果觉得项目还不错，想要表达些什么的话，可以上[爱淘汇：http://itao.wolfbe.com](http://itao.wolfbe.com) 领淘宝天猫的优惠券，领取优惠券再下单可以省不少钱喔。你们使用这些优惠券购买东西时，我也可以得到一些佣金的，多谢支持！！！
<br>
<br>






